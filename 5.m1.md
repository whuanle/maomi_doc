# 模块化和自动服务注册的实现

请先阅读第一章 [模块化的使用](1.module.md)



我们思考模块化框架需要解决哪些问题或支持哪些功能：

* 如何识别和注册服务；
* 框架能够识别模块的依赖，生成模块依赖树，能够检测到循环依赖等问题；
* 多个模块可能引用了同一个模块 A，但是模块 A 只能被实例化一次；
* 初始化模块的顺序；

* 模块类本身要作为服务注册到容器中，实例化模块类时，需要支持依赖注入，也就是说模块类的构造函数可以注入其它服务；



### 模块化设计

**1，模块依赖。**

`[InjectModule<ApplicationModule>]`  表示当前模块需要依赖哪些模块。如果需要依赖多个模块，可以使用多个特性，示例如下：

```csharp
[InjectModule<DomainModule>]
[InjectModule<ApplicationModule>]
```



**2，模块接口和初始化。**

每一个模块都需要实现 IModule 接口，框架识别到类型继承了这个接口后才会把类型当作一个模块类进行处理。IModule 接口很简单，只有 `ConfigureServices(ServiceContext context)` 一个方法，可以在这个方法中编写初始化模块的代码。



**3，依赖注入**

每个模块的构造函数都可以使用依赖注入，可以在模块类中注入需要的服务，开发者可以在模块初始化时，通过这些服务初始化模块。



基于以上三点，我们可以先抽象出特性类、接口等，由于这些类型不包含具体的逻辑，因此从这一部分先下手，实现起来会更简单，可以避免大脑混乱，编写框架时不知道要从哪里先下手。





创建一个 `ServiceContext` 类，用于在模块间传递服务上下文信息，其代码如下：

```csharp
    public class ServiceContext
    {
        private readonly IServiceCollection _serviceCollection;
        private readonly IConfiguration _configuration;

        internal ServiceContext(IServiceCollection serviceCollection, IConfiguration configuration)
        {
            _serviceCollection = serviceCollection;
            _configuration = configuration;
        }

        public IServiceCollection Services => _serviceCollection;
        public IConfiguration Configuration => _configuration;
    }
```

> 根据实际需求，还可以在 ServiceContext 中添加日志等属性字段。





创建 IModule 接口。

```csharp
    public interface IModule
    {
        void ConfigureServices(ServiceContext services);
    }
```



创建 `InjectModuleAttribute` 特性，用于引入依赖模块。

```csharp
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public class InjectModuleAttribute : Attribute
    {
        // 依赖的模块
        public Type ModuleType { get; private init; }
        public InjectModuleAttribute(Type type)
        {
            ModuleType = type;
        }
    }

    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public sealed class InjectModuleAttribute<TModule> : InjectModuleAttribute
        where TModule : IModule
    {
        public InjectModuleAttribute() : base(typeof(TModule)){}
    }
```

> 泛型特性属于 C# 11 的新语法。



定义两个特性类后，我们可以使用 `[InjectModule(typeof(AppModule))]` 或 `InjectModule<AppModule>` 的方式定义依赖模块。



#### 自动服务注册的设计

当完成本章的代码编写后，如果需要注入服务，只需要标记 `[InjectOn]` 特性即可。

```csharp
// 简单注册
[InjectOn]
public class MyService : IMyService
// 注注册并设置生命周期为 scope
[InjectOn(ServiceLifetime.Scoped)]
public class MyService : IMyService

// 只注册接口，不注册父类
[InjectOn(InjectScheme.OnlyInterfaces)]
public class MyService : ParentService, IMyService
```



有时我们会有各种各样的需求，例如 `MyService` 继承了父类 `ParentService` 和接口 `IMyService`，但是只需要注册 `ParentService`，而不需要注册接口；又或者只需要注册 MyService，而不需要注册  `ParentService` 、 `IMyService`。

创建 InjectScheme 枚举，定义注册模式：

```csharp
    public enum InjectScheme
    {
        // 注入父类、接口
        Any,
        
        // 手动选择要注入的服务
        Some,
        
        // 只注入父类
        OnlyBaseClass,
        
        // 只注入实现的接口
        OnlyInterfaces,
        
        // 此服务不会被注入到容器中
        None
    }
```



定义服务注册特性：

```csharp
    // 依赖注入标记
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
    public class InjectOnAttribute : Attribute
    {
        // 要注入的服务
        public Type[]? ServicesType { get; set; }
        
        // 生命周期
        public ServiceLifetime Lifetime { get; set; }
        
        // 注入模式
        public InjectScheme Scheme { get; set; }

        // 是否注入自己
        public bool Own { get; set; } = false;
        
        public InjectOnAttribute(ServiceLifetime lifetime = ServiceLifetime.Transient, 
                                 InjectScheme scheme = InjectScheme.OnlyInterfaces)
        {
            Lifetime = lifetime;
            Scheme = scheme;
        }
    }
```



#### 模块依赖

因为模块之间会有依赖关系，因此为了生成模块树，需要定义一个 ModuleNode 类表示模块节点，**一个 ModuleNode 实例标识一个依赖关系**。

```csharp
    /// <summary>
    /// 模块节点
    /// </summary>
    internal class ModuleNode
    {
        // 当前模块类型
        public Type ModuleType { get; set; } = null!;

        // 链表，指向父模块节点，用于循环引用检测
        public ModuleNode? ParentModule { get; set; }
        
        // 依赖的其它模块
        public HashSet<ModuleNode>? Childs { get; set; }

        // 通过链表检测是否出现了循环依赖
        public bool ContainsTree(ModuleNode childModule)
        {
            if (childModule.ModuleType == ModuleType) return true;
            if (this.ParentModule == null) return false;
            // 如果当前模块找不到记录，则向上查找
            return this.ParentModule.ContainsTree(childModule);
        }

        public override int GetHashCode()
        {
            return ModuleType.GetHashCode();
        }

        public override bool Equals(object? obj)
        {
            if (obj == null) return false;
            if(obj is ModuleNode module)
            {
                return GetHashCode() == module.GetHashCode();
            }
            return false;
        }
    }
```





#### 实现模块化和自动服务注册

因为自动服务注册是根据模块所在的程序集扫描标记类，识别所有使用了 `InjectOnAttribute` 特性的类型，所以我们可以先编写一个程序集扫描方法，该方法的功能是通过程序集扫描所有类型，然后根据特性配置注册服务。



```csharp
/// <summary>
/// 自动依赖注入
/// </summary>
/// <param name="services"></param>
/// <param name="assembly"></param>
/// <param name="injectTypes">已被注入的服务</param>
private static void InitInjectService(IServiceCollection services, Assembly assembly, HashSet<Type> injectTypes)
{
	// 只扫描可实例化的类，不扫描静态类、接口、抽象类、嵌套类、非公开类等
	foreach (var item in assembly.GetTypes().Where(x => x.IsClass && !x.IsAbstract && !x.IsNestedPublic))
	{
		var inject = item.GetCustomAttributes().FirstOrDefault(x => x.GetType() == typeof(InjectOnAttribute)) as InjectOnAttribute;
		if (inject == null) continue;

		if (injectTypes.Contains(item)) continue;
		injectTypes.Add(item);

		// 如果需要注入自身
		if (inject.Own)
		{
			switch (inject.Lifetime)
			{
				case ServiceLifetime.Transient: services.AddTransient(item); break;
				case ServiceLifetime.Scoped: services.AddScoped(item); break;
				case ServiceLifetime.Singleton: services.AddSingleton(item); break;
			}
		}

		if (inject.Scheme == InjectScheme.None) continue;

		// 注入所有接口
		if (inject.Scheme == InjectScheme.OnlyInterfaces || inject.Scheme == InjectScheme.Any)
		{
			var interfaces = item.GetInterfaces();
			if (interfaces.Count() == 0) continue;
			switch (inject.Lifetime)
			{
				case ServiceLifetime.Transient: interfaces.ToList().ForEach(x => services.AddTransient(x, item)); break;
				case ServiceLifetime.Scoped: interfaces.ToList().ForEach(x => services.AddScoped(x, item)); break;
				case ServiceLifetime.Singleton: interfaces.ToList().ForEach(x => services.AddSingleton(x, item)); break;
			}
		}

		// 注入父类
		if (inject.Scheme == InjectScheme.OnlyBaseClass || inject.Scheme == InjectScheme.Any)
		{
			var baseType = item.BaseType;
			if (baseType == null) throw new ArgumentException($"{item.Name} 注入模式 {nameof(inject.Scheme)} 未找到父类！");
			switch (inject.Lifetime)
			{
				case ServiceLifetime.Transient: services.AddTransient(baseType, item); break;
				case ServiceLifetime.Scoped: services.AddScoped(baseType, item); break;
				case ServiceLifetime.Singleton: services.AddSingleton(baseType, item); break;
			}
		}
		if (inject.Scheme == InjectScheme.Some)
		{
			var types = inject.ServicesType;
			if (types == null) throw new ArgumentException($"{item.Name} 注入模式 {nameof(inject.Scheme)} 未找到服务！");
			switch (inject.Lifetime)
			{
				case ServiceLifetime.Transient: types.ToList().ForEach(x => services.AddTransient(x, item)); break;
				case ServiceLifetime.Scoped: types.ToList().ForEach(x => services.AddScoped(x, item)); break;
				case ServiceLifetime.Singleton: types.ToList().ForEach(x => services.AddSingleton(x, item)); break;
			}
		}
	}
}
```



定义两个扩展函数，用于注入入口模块。

```csharp
		/// <summary>
		/// 注册模块化服务
		/// </summary>
		/// <typeparam name="TModule">入口模块</typeparam>
		/// <param name="services"></param>
		public static void AddModule<TModule>(this IServiceCollection services)
			where TModule : IModule
		{
			AddModule(services, typeof(TModule));
		}


		/// <summary>
		/// 注册模块化服务
		/// </summary>
		/// <param name="services"></param>
		/// <param name="startupModule">入口模块</param>
		public static void AddModule(this IServiceCollection services, Type startupModule)
		{
			if (startupModule?.GetInterface(nameof(IModule)) == null)
			{
				throw new TypeLoadException($"{startupModule?.Name} 不是有效的模块类");
			}

			IServiceProvider scope = BuildModule(services, startupModule);
		}
```



框架需要从入口模块程序集开始查找被依赖的模块程序集，然后通过后序遍历初始化每个模块，并扫描该模块程序集中的服务。

创建一个 `BuildModule` 函数，BuildModule 为构建模块依赖树、初始化模块提前创建环境。

```csharp
		/// <summary>
		/// 构建模块依赖树并初始化模块
		/// </summary>
		/// <param name="services"></param>
		/// <param name="startupModule"></param>
		/// <returns></returns>
		/// <exception cref="InvalidOperationException"></exception>
		private static IServiceProvider BuildModule(IServiceCollection services, Type startupModule)
		{
			// 生成根模块
			ModuleNode rootTree = new ModuleNode()
			{
				ModuleType = startupModule,
				Childs = new HashSet<ModuleNode>()
			};

			// 根模块依赖的其他模块
			// IModule => InjectModuleAttribute
			var rootDependencies = startupModule.GetCustomAttributes(false)
				.Where(x => x.GetType().IsSubclassOf(typeof(InjectModuleAttribute)))
				.OfType<InjectModuleAttribute>();

			// 构建模块依赖树
			BuildTree(services, rootTree, rootDependencies);

			// 构建一个 Ioc 实例，以便初始化模块类
			var scope = services.BuildServiceProvider();

			// 初始化所有模块类
			var serviceContext = new ServiceContext(services, scope.GetService<IConfiguration>()!);

			// 记录已经处理的程序集、模块和服务，以免重复处理
			HashSet<Assembly> moduleAssemblies = new HashSet<Assembly> { startupModule.Assembly };
			HashSet<Type> moduleTypes = new HashSet<Type>();
			HashSet<Type> injectTypes = new HashSet<Type>();

            // 后序遍历树并初始化每个模块
			InitModuleTree(scope, serviceContext, moduleAssemblies, moduleTypes, injectTypes, rootTree);

			return scope;
		}
```



第一步，构建模块依赖树。

```csharp
		/// <summary>
		/// 构建模块依赖树
		/// </summary>
		/// <param name="services"></param>
		/// <param name="currentNode"></param>
		/// <param name="injectModules">其依赖的模块</param>
		private static void BuildTree(IServiceCollection services, ModuleNode currentNode, IEnumerable<InjectModuleAttribute> injectModules)
		{
			services.AddTransient(currentNode.ModuleType);
			if (injectModules == null || injectModules.Count() == 0) return;
			foreach (var childModule in injectModules)
			{
				var childTree = new ModuleNode
				{
					ModuleType = childModule.ModuleType,
					ParentModule = currentNode
				};

				// 循环依赖检测
				// 检查当前模块(parentTree)依赖的模块(childTree)是否在之前出现过，如果是，则说明是循环依赖
				var isLoop = currentNode.ContainsTree(childTree);
				if (isLoop)
				{
					throw new OverflowException($"检测到循环依赖引用或重复引用！{currentNode.ModuleType.Name} 依赖的 {childModule.ModuleType.Name} 模块在其父模块中出现过！");
				}

				if (currentNode.Childs == null)
				{
					currentNode.Childs = new HashSet<ModuleNode>();
				}

				currentNode.Childs.Add(childTree);
				// 子模块依赖的其他模块
				var childDependencies = childModule.ModuleType.GetCustomAttributes(inherit: false)
					.Where(x => x.GetType().IsSubclassOf(typeof(InjectModuleAttribute))).OfType<InjectModuleAttribute>().ToHashSet();
				// 子模块也依赖其他模块
				BuildTree(services, childTree, childDependencies);
			}
		}
```



通过后序遍历识别依赖时，由于一个模块可能会出现多次，所以初始化时需要判断模块是否已经初始化，然后对模块进行初始化并扫描模块程序集中所有的类型，进行服务注册。

```csharp
		/// <summary>
		/// 从模块树中遍历
		/// </summary>
		/// <param name="serviceProvider"></param>
		/// <param name="context"></param>
		/// <param name="moduleTypes">已经被注册到容器中的模块类</param>
		/// <param name="moduleAssemblies">模块类所在的程序集</param>'
		/// <param name="injectTypes">已被注册到容器的服务</param>
		/// <param name="moduleNode">模块节点</param>
		private static void InitModuleTree(IServiceProvider serviceProvider,
			ServiceContext context,
			HashSet<Assembly> moduleAssemblies,
			HashSet<Type> moduleTypes,
			HashSet<Type> injectTypes,
			ModuleNode moduleNode)
		{
			if (moduleNode.Childs != null)
			{
				foreach (var item in moduleNode.Childs)
				{
					InitModuleTree(serviceProvider, context, moduleAssemblies, moduleTypes, injectTypes, item);
				}
			}

			// 如果模块没有处理过
			if (!moduleTypes.Contains(moduleNode.ModuleType))
			{
				moduleTypes.Add(moduleNode.ModuleType);

				// 实例化此模块
				// 扫描此模块（程序集）中需要依赖注入的服务
				var module = (IModule)serviceProvider.GetRequiredService(moduleNode.ModuleType);
				module.ConfigureServices(context);
				InitInjectService(context.Services, moduleNode.ModuleType.Assembly, injectTypes);
				moduleAssemblies.Add(moduleNode.ModuleType.Assembly);
			}
		}

```

