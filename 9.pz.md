# 实现自定义配置提供器

在本节中，笔者将会介绍如何编写一个从文件导入的配置提供器，并且实现随文件变化动态更新到内存中。

代码示例在 `Demo4.Console` 中。

引入 `Microsoft.Extensions.FileProviders.Physical` ，用于监听目录、文件变化。



我们将来实现读取自定义配置格式的文件，创建一个 env.conf 文件，内容如下：

```
A:111
B:222
```

配置文件通过 `:` 号来分隔 key 和 value，



我们要实现自定义配置提供器，需要先编写一个配置源，需要继承 IConfigurationSource 接口，其接口定义非常简单：

```csharp
	public interface IConfigurationSource
	{
		IConfigurationProvider Build(IConfigurationBuilder builder);
	}
```



创建一个 MyConfigurationSource 类型，代码如下：

```csharp
    public class MyConfigurationSource : IConfigurationSource
    {
        // 配置文件的路径
        public string Path { get; set; }
        // 是否实时监听此文件变化
        public bool ReloadOnChange { get; set; }
        public IConfigurationProvider Build(IConfigurationBuilder builder)
        {
            return new MyConfigurationProvider(this);
        }
    }
```



接着定义配置提供器，配置提供器需要存储配置信息，提供配置查询等接口。



代码示例如下：

```csharp
public class MyConfigurationProvider : IConfigurationProvider
{
	private readonly MyConfigurationSource _source;
	private readonly IFileProvider _fileProvider;

	private readonly string _path;
	private readonly string _fileName;

    // 缓存
	private readonly Dictionary<string, string> _cache;
    
	public MyConfigurationProvider(MyConfigurationSource source)
	{
		_source = source;
		_cache = new Dictionary<string, string>();
	
		_path = Directory.GetParent(_source.Path)!.FullName;
		_fileName = Path.GetFileName(_source.Path);

		_fileProvider = new PhysicalFileProvider(_path);
		if (_source.ReloadOnChange)
		{
            // 监听配置文件变化
			ChangeToken.OnChange(() => _fileProvider.Watch(_fileName), async () => await ReloadFileAsync());
		}
		else
		{
			ReloadFileAsync().Wait();
		}
	}
    
	// 重新加载配置文件到内存中
	private async Task ReloadFileAsync()
	{
		using var stream = _fileProvider.GetFileInfo(_fileName).CreateReadStream();
		using var streamReader = new StreamReader(stream);
		_cache.Clear();
		while (true)
		{
			var line = await streamReader.ReadLineAsync();
			if (line == null) break;
			var kv = line.Split(':')[0..2].Select(x => x.Trim(' ')).ToArray();
			_cache.Add(kv[0], kv[1]);
		}
	}

	public IEnumerable<string> GetChildKeys(IEnumerable<string> earlierKeys, string? parentPath) => _cache.Keys;

	public IChangeToken GetReloadToken() => null;

	public void Load()
	{
		ReloadFileAsync().Wait();
	}

	public void Set(string key, string? value)
	{
		_cache[key] = value!;
	}

	public bool TryGet(string key, out string? value)
	{
		return _cache.TryGetValue(key, out value);
	}
}
```



接着定义扩展，以便支持外部依赖注入：

```csharp
public static class Extensions
{
    public static IConfigurationBuilder AddEnvFile(this IConfigurationBuilder builder, string path, bool reloadOnChange = false)
    {
        var source = new MyConfigurationSource()
        {
            Path = path,
            ReloadOnChange = reloadOnChange
        };
        builder.Add(source);
        return builder;
    }
}
```



然后使用我们自定义的配置提供器：

```csharp
	static void Main()
	{
		var configuration = new ConfigurationBuilder()
			.AddEnvFile("env.conf", true)
			.Build();
		while (true)
		{
			var value = configuration["A"];
			Console.WriteLine($"A = {value}");
			Thread.Sleep(1000);
		}
	}
```



启动程序后，修改程序运行目录下的 env.conf 文件，查看控制台中的输出，检查控制台的输出是否与修改后的文件一致。



